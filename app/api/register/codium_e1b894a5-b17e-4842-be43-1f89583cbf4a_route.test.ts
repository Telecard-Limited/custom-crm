

import bcrypt from "bcrypt";
import dbConnect from "@/lib/prisma/dbconn";
import { User, UserType } from "../models";
import { NextResponse } from "next/server";
import { NextApiRequest, NextApiResponse } from "next";

dbConnect();
console.log("db connect");
export async function GET(request: NextApiRequest) {
  try {
    const { email } = request.body;
    const user = await User?.find({
      email: email,
    });

    if (!user || user.length === 0) {
      return NextResponse.json({
        status: 404, // Not Found
        message: "User not found",
      });
    }

    // Return a sanitized user object with only the necessary fields
    const sanitizedUsers = user.map((userData) => ({
      _id: userData._id,
      name: userData.name,
      email: userData.email,
      country: userData.country,
      phoneNumber: userData.phoneNumber,
      role: userData.role,
    }));

    return NextResponse.json(sanitizedUsers);
  } catch (error) {
    console.error("Error fetching user:", error);
    return NextResponse.json({
      status: 500, // Internal Server Error
      message: "Internal server error",
    });
  }
}

export async function POST(req: NextApiRequest, res: NextApiResponse) {
  try {
    console.log("RESS", req.body);
    const { email, name, password, phoneNumber, country } = req.body;

    // Check if all required fields are provided
    if (!name || !email || !password || !phoneNumber || !country) {
      console.log("error in regitering userdata");
      // Check if a user with the same email already exists
      // const userAvailable = await User?.findOne({
      //   email: email,
      // });

      // if (userAvailable) {
      //   return NextResponse.json({
      //     status: 409, // Conflict
      //     message: "User with this email already exists",
      //   });
      // }

      // Hash the password
      const hashedPassword = await bcrypt.hash(password, 12);

      // Create the user
      const user = await User?.create({
        name,
        email,
        password: hashedPassword,
        phoneNumber,
        country,
      });

      // Return a sanitized user object in the response
      const sanitizedUser = {
        _id: user._id,
        name: user.name,
        email: user.email,
        country: user.country,
        phoneNumber: user.phoneNumber,
        role: user.role,
      };

      return NextResponse.json(sanitizedUser);
    }
    return NextResponse.json({
      status: 400, // Bad Request
      message: "All fields are required",
    });
  } catch (err) {
    console.error(err);
    return NextResponse.json({
      status: 500, // Internal Server Error
      message: "Internal server error",
    });
  }
}


// Generated by CodiumAI

describe('POST', () => {

    // User provides all required fields, user is created and sanitized user object is returned in the response.
    it('should create user and return sanitized user object', async () => {
      const req = {
        body: {
          email: 'test@example.com',
          name: 'Test User',
          password: 'password123',
          phoneNumber: '1234567890',
          country: 'USA',
        },
      };
      const res = {
        json: jest.fn(),
      };

      await POST(req, res);

      expect(res.json).toHaveBeenCalledWith({
        _id: expect.any(String),
        name: 'Test User',
        email: 'test@example.com',
        country: 'USA',
        phoneNumber: '1234567890',
        role: expect.any(String),
      });
    });
});
